{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"<code>scientific_pydantic</code>","text":""},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference<ul> <li>astropy<ul> <li>units</li> </ul> </li> <li>numpy</li> <li>scipy<ul> <li>spatial<ul> <li>transform</li> </ul> </li> </ul> </li> <li>shapely</li> </ul> </li> </ul>"},{"location":"api/scientific_pydantic/","title":"<code>scientific_pydantic</code>","text":"<pre><code>import scientific_pydantic\n</code></pre>"},{"location":"api/scientific_pydantic/#scientific_pydantic","title":"<code>scientific_pydantic</code>","text":"<p>Pydantic adapters for common scientific libraries</p> <p>Adapters in the root of this package are for Python standard library types ONLY.</p> <p>Subpackages shall follow the structure of their library and exist at the same path as the type they are adapting. For instance, the adapter <code>astropy.units.UnitBase</code> lives in <code>scientific_pydantic.astropy.units</code>.</p>"},{"location":"api/scientific_pydantic/#scientific_pydantic.EllipsisLiteral","title":"<code>EllipsisLiteral = ty.Annotated[types.EllipsisType, EllipsisAdapter()]</code>  <code>module-attribute</code>","text":""},{"location":"api/scientific_pydantic/#scientific_pydantic.IntSliceAdapter","title":"<code>IntSliceAdapter = SliceAdapter(int)</code>  <code>module-attribute</code>","text":""},{"location":"api/scientific_pydantic/#scientific_pydantic.EllipsisAdapter","title":"<code>EllipsisAdapter</code>","text":"<p>A Pydantic annotation for the Ellipsis singleton (...).</p> Source code in <code>src/scientific_pydantic/ellipsis.py</code> <pre><code>class EllipsisAdapter:\n    \"\"\"A Pydantic annotation for the Ellipsis singleton (...).\"\"\"\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: ty.Any, handler: pydantic.GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"Get the pydantic schema for this type\"\"\"\n        del handler\n\n        if source_type is not types.EllipsisType and not (\n            ty.get_origin(source_type) is ty.Literal\n            and len(args := ty.get_args(source_type)) &gt; 0\n            and args[0] is Ellipsis\n        ):\n            msg = (\n                \"EllipsisAdapter is only usable with EllipsisType or \"\n                f\"Literal[Ellipsis], not {source_type}\"\n            )\n            raise pydantic.PydanticSchemaGenerationError(msg)\n\n        return core_schema.no_info_plain_validator_function(\n            cls._validate,\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                lambda _: \"...\",\n                when_used=\"json\",\n            ),\n        )\n\n    @classmethod\n    def _validate(cls, value: ty.Any) -&gt; types.EllipsisType:\n        if value is ... or value == \"...\":\n            return ...\n        msg = f\"Expected Ellipsis (...), got {value!r}\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"api/scientific_pydantic/#scientific_pydantic.EllipsisAdapter.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source_type: ty.Any, handler: pydantic.GetCoreSchemaHandler) -&gt; core_schema.CoreSchema</code>  <code>classmethod</code>","text":"<p>Get the pydantic schema for this type</p> Source code in <code>src/scientific_pydantic/ellipsis.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls, source_type: ty.Any, handler: pydantic.GetCoreSchemaHandler\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Get the pydantic schema for this type\"\"\"\n    del handler\n\n    if source_type is not types.EllipsisType and not (\n        ty.get_origin(source_type) is ty.Literal\n        and len(args := ty.get_args(source_type)) &gt; 0\n        and args[0] is Ellipsis\n    ):\n        msg = (\n            \"EllipsisAdapter is only usable with EllipsisType or \"\n            f\"Literal[Ellipsis], not {source_type}\"\n        )\n        raise pydantic.PydanticSchemaGenerationError(msg)\n\n    return core_schema.no_info_plain_validator_function(\n        cls._validate,\n        serialization=core_schema.plain_serializer_function_ser_schema(\n            lambda _: \"...\",\n            when_used=\"json\",\n        ),\n    )\n</code></pre>"},{"location":"api/scientific_pydantic/#scientific_pydantic.RangeAdapter","title":"<code>RangeAdapter</code>","text":"<p>Pydantic adapter for Python <code>range</code> using slice syntax.</p> Source code in <code>src/scientific_pydantic/range.py</code> <pre><code>class RangeAdapter:\n    \"\"\"Pydantic adapter for Python ``range`` using slice syntax.\"\"\"\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source_type: ty.Any,\n        _handler: pydantic.GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"Get the pydantic schema for this type\"\"\"\n\n        def _validate(value: ty.Any) -&gt; range:\n            if isinstance(value, range):\n                return value\n\n            if isinstance(value, str):\n                try:\n                    start, stop, step = parse_slice_syntax(\n                        value,\n                        converter=int,\n                        require_start=False,\n                        require_stop=True,\n                    )\n                except SliceSyntaxError as exc:\n                    raise ValueError(str(exc)) from exc\n\n                return range(\n                    start if start is not None else 0,\n                    stop,\n                    step if step is not None else 1,\n                )\n\n            msg = \"Expected range or slice-syntax string\"\n            raise ValueError(msg)\n\n        def _serialize(value: range) -&gt; str:\n            step = None if value.step == 1 else value.step\n            return format_slice_syntax(value.start, value.stop, step)\n\n        return core_schema.no_info_plain_validator_function(\n            _validate,\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                _serialize,\n                when_used=\"json\",\n            ),\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls,\n        _core_schema: core_schema.CoreSchema,\n        _handler: pydantic.GetJsonSchemaHandler,\n    ) -&gt; JsonSchemaValue:\n        \"\"\"Get the JSON schema for this type\"\"\"\n        return {\n            \"type\": \"string\",\n            \"title\": \"range\",\n            \"description\": \"Python range syntax: start:stop[:step]\",\n            \"pattern\": r\"^\\s*-?\\d+\\s*:\\s*-?\\d+\\s*(?::\\s*-?\\d+\\s*)?$\",\n        }\n</code></pre>"},{"location":"api/scientific_pydantic/#scientific_pydantic.RangeAdapter.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(_source_type: ty.Any, _handler: pydantic.GetCoreSchemaHandler) -&gt; core_schema.CoreSchema</code>  <code>classmethod</code>","text":"<p>Get the pydantic schema for this type</p> Source code in <code>src/scientific_pydantic/range.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls,\n    _source_type: ty.Any,\n    _handler: pydantic.GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Get the pydantic schema for this type\"\"\"\n\n    def _validate(value: ty.Any) -&gt; range:\n        if isinstance(value, range):\n            return value\n\n        if isinstance(value, str):\n            try:\n                start, stop, step = parse_slice_syntax(\n                    value,\n                    converter=int,\n                    require_start=False,\n                    require_stop=True,\n                )\n            except SliceSyntaxError as exc:\n                raise ValueError(str(exc)) from exc\n\n            return range(\n                start if start is not None else 0,\n                stop,\n                step if step is not None else 1,\n            )\n\n        msg = \"Expected range or slice-syntax string\"\n        raise ValueError(msg)\n\n    def _serialize(value: range) -&gt; str:\n        step = None if value.step == 1 else value.step\n        return format_slice_syntax(value.start, value.stop, step)\n\n    return core_schema.no_info_plain_validator_function(\n        _validate,\n        serialization=core_schema.plain_serializer_function_ser_schema(\n            _serialize,\n            when_used=\"json\",\n        ),\n    )\n</code></pre>"},{"location":"api/scientific_pydantic/#scientific_pydantic.RangeAdapter.__get_pydantic_json_schema__","title":"<code>__get_pydantic_json_schema__(_core_schema: core_schema.CoreSchema, _handler: pydantic.GetJsonSchemaHandler) -&gt; JsonSchemaValue</code>  <code>classmethod</code>","text":"<p>Get the JSON schema for this type</p> Source code in <code>src/scientific_pydantic/range.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    _core_schema: core_schema.CoreSchema,\n    _handler: pydantic.GetJsonSchemaHandler,\n) -&gt; JsonSchemaValue:\n    \"\"\"Get the JSON schema for this type\"\"\"\n    return {\n        \"type\": \"string\",\n        \"title\": \"range\",\n        \"description\": \"Python range syntax: start:stop[:step]\",\n        \"pattern\": r\"^\\s*-?\\d+\\s*:\\s*-?\\d+\\s*(?::\\s*-?\\d+\\s*)?$\",\n    }\n</code></pre>"},{"location":"api/scientific_pydantic/#scientific_pydantic.SliceAdapter","title":"<code>SliceAdapter</code>","text":"<p>Pydantic adapter for Python's built-in <code>slice</code>.</p> <p>JSON representation: <code>\"[start]:[stop][:step]\"</code></p> Source code in <code>src/scientific_pydantic/slice.py</code> <pre><code>class SliceAdapter:\n    \"\"\"Pydantic adapter for Python's built-in `slice`.\n\n    JSON representation: `\"[start]:[stop][:step]\"`\n    \"\"\"\n\n    def __init__(\n        self,\n        default_type: type = str,\n        *,\n        start_type: type | None = None,\n        stop_type: type | None = None,\n        step_type: type | None = None,\n    ) -&gt; None:\n        distinct_types = {default_type, start_type, stop_type, step_type}\n        adapters = {\n            t: pydantic.TypeAdapter(t) for t in distinct_types if t not in (None, str)\n        }\n        self._default_adapter = (\n            adapters[default_type] if default_type is not str else None\n        )\n\n        self._start_adapter = (\n            adapters[start_type]\n            if start_type not in (str, None)\n            else self._default_adapter\n        )\n        self._stop_adapter = (\n            adapters[stop_type]\n            if stop_type not in (str, None)\n            else self._default_adapter\n        )\n        self._step_adapter = (\n            adapters[step_type]\n            if step_type not in (str, None)\n            else self._default_adapter\n        )\n\n    def __get_pydantic_core_schema__(  # noqa: C901\n        self,\n        _source_type: ty.Any,\n        _handler: pydantic.GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"Get the pydantic schema for this type\"\"\"\n\n        def _validate(value: ty.Any) -&gt; slice:\n            match value:\n                case slice():\n                    return value\n                case Mapping():\n                    start, stop, step = _from_mapping(value)\n                case str():\n                    start, stop, step = _from_str(value)\n                case Sequence():\n                    start, stop, step = _from_sequence(value)\n                case _:\n                    msg = \"Expected a slice, sequence, mapping or str\"\n                    raise ValueError(msg)\n\n            if start is not None and self._start_adapter is not None:\n                start = self._start_adapter.validate_python(start)\n            if stop is not None and self._stop_adapter is not None:\n                stop = self._stop_adapter.validate_python(stop)\n            if step is not None and self._step_adapter is not None:\n                step = self._step_adapter.validate_python(step)\n            return slice(start, stop, step)\n\n        def _serialize(value: slice) -&gt; str | dict[str, ty.Any]:\n            if all(\n                x is None or isinstance(x, numbers.Number)\n                for x in (value.start, value.stop, value.step)\n            ):\n                return format_slice_syntax(value.start, value.stop, value.step)\n\n            return {\n                \"start\": value.start,\n                \"stop\": value.stop,\n                \"step\": value.step,\n            }\n\n        return core_schema.no_info_plain_validator_function(\n            _validate,\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                _serialize,\n                when_used=\"json\",\n            ),\n        )\n\n    def __get_pydantic_json_schema__(\n        self,\n        _core_schema: core_schema.CoreSchema,\n        handler: pydantic.GetJsonSchemaHandler,\n    ) -&gt; JsonSchemaValue:\n        \"\"\"Get the JSON schema for this object\"\"\"\n        return handler(\n            core_schema.union_schema(\n                [\n                    core_schema.str_schema(),\n                    core_schema.list_schema(min_length=1, max_length=3),\n                    core_schema.typed_dict_schema(\n                        {\n                            \"start\": core_schema.typed_dict_field(\n                                self._start_adapter.core_schema\n                                if self._start_adapter is not None\n                                else core_schema.any_schema(),\n                            ),\n                            \"stop\": core_schema.typed_dict_field(\n                                self._stop_adapter.core_schema\n                                if self._stop_adapter is not None\n                                else core_schema.any_schema(),\n                            ),\n                            \"step\": core_schema.typed_dict_field(\n                                self._step_adapter.core_schema\n                                if self._step_adapter is not None\n                                else core_schema.any_schema(),\n                            ),\n                        },\n                        total=False,\n                    ),\n                ],\n            ),\n        )\n</code></pre>"},{"location":"api/scientific_pydantic/#scientific_pydantic.SliceAdapter.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(_source_type: ty.Any, _handler: pydantic.GetCoreSchemaHandler) -&gt; core_schema.CoreSchema</code>","text":"<p>Get the pydantic schema for this type</p> Source code in <code>src/scientific_pydantic/slice.py</code> <pre><code>def __get_pydantic_core_schema__(  # noqa: C901\n    self,\n    _source_type: ty.Any,\n    _handler: pydantic.GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Get the pydantic schema for this type\"\"\"\n\n    def _validate(value: ty.Any) -&gt; slice:\n        match value:\n            case slice():\n                return value\n            case Mapping():\n                start, stop, step = _from_mapping(value)\n            case str():\n                start, stop, step = _from_str(value)\n            case Sequence():\n                start, stop, step = _from_sequence(value)\n            case _:\n                msg = \"Expected a slice, sequence, mapping or str\"\n                raise ValueError(msg)\n\n        if start is not None and self._start_adapter is not None:\n            start = self._start_adapter.validate_python(start)\n        if stop is not None and self._stop_adapter is not None:\n            stop = self._stop_adapter.validate_python(stop)\n        if step is not None and self._step_adapter is not None:\n            step = self._step_adapter.validate_python(step)\n        return slice(start, stop, step)\n\n    def _serialize(value: slice) -&gt; str | dict[str, ty.Any]:\n        if all(\n            x is None or isinstance(x, numbers.Number)\n            for x in (value.start, value.stop, value.step)\n        ):\n            return format_slice_syntax(value.start, value.stop, value.step)\n\n        return {\n            \"start\": value.start,\n            \"stop\": value.stop,\n            \"step\": value.step,\n        }\n\n    return core_schema.no_info_plain_validator_function(\n        _validate,\n        serialization=core_schema.plain_serializer_function_ser_schema(\n            _serialize,\n            when_used=\"json\",\n        ),\n    )\n</code></pre>"},{"location":"api/scientific_pydantic/#scientific_pydantic.SliceAdapter.__get_pydantic_json_schema__","title":"<code>__get_pydantic_json_schema__(_core_schema: core_schema.CoreSchema, handler: pydantic.GetJsonSchemaHandler) -&gt; JsonSchemaValue</code>","text":"<p>Get the JSON schema for this object</p> Source code in <code>src/scientific_pydantic/slice.py</code> <pre><code>def __get_pydantic_json_schema__(\n    self,\n    _core_schema: core_schema.CoreSchema,\n    handler: pydantic.GetJsonSchemaHandler,\n) -&gt; JsonSchemaValue:\n    \"\"\"Get the JSON schema for this object\"\"\"\n    return handler(\n        core_schema.union_schema(\n            [\n                core_schema.str_schema(),\n                core_schema.list_schema(min_length=1, max_length=3),\n                core_schema.typed_dict_schema(\n                    {\n                        \"start\": core_schema.typed_dict_field(\n                            self._start_adapter.core_schema\n                            if self._start_adapter is not None\n                            else core_schema.any_schema(),\n                        ),\n                        \"stop\": core_schema.typed_dict_field(\n                            self._stop_adapter.core_schema\n                            if self._stop_adapter is not None\n                            else core_schema.any_schema(),\n                        ),\n                        \"step\": core_schema.typed_dict_field(\n                            self._step_adapter.core_schema\n                            if self._step_adapter is not None\n                            else core_schema.any_schema(),\n                        ),\n                    },\n                    total=False,\n                ),\n            ],\n        ),\n    )\n</code></pre>"},{"location":"api/scientific_pydantic/astropy/","title":"<code>astropy</code>","text":"<pre><code>import scientific_pydantic.astropy\n</code></pre> <p>See subpackages below.</p>"},{"location":"api/scientific_pydantic/astropy/units/","title":"<code>units</code>","text":"<pre><code>import scientific_pydantic.astropy.units\n</code></pre>"},{"location":"api/scientific_pydantic/astropy/units/#scientific_pydantic.astropy.units","title":"<code>units</code>","text":"<p>Pydantic adapters for astropy.units</p>"},{"location":"api/scientific_pydantic/astropy/units/#scientific_pydantic.astropy.units.PhysicalTypeAdapter","title":"<code>PhysicalTypeAdapter</code>","text":"<p>A pydantic adapter for astropy.units.PhysicalType</p> Source code in <code>src/scientific_pydantic/astropy/units/physical_type.py</code> <pre><code>class PhysicalTypeAdapter:\n    \"\"\"A pydantic adapter for astropy.units.PhysicalType\"\"\"\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        source_type: ty.Any,\n        handler: pydantic.GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"Get the pydantic schema for this type\"\"\"\n        import astropy.units as u\n\n        from .validators import validate_physical_type\n\n        del handler\n\n        if source_type is not u.PhysicalType:\n            msg = (\n                \"PhysicalTypeAdapter is only usable with \"\n                f\"astropy.units.PhysicalType, not {source_type}.\"\n            )\n            raise pydantic.PydanticSchemaGenerationError(msg)\n\n        validator = core_schema.no_info_plain_validator_function(validate_physical_type)\n\n        return core_schema.json_or_python_schema(\n            json_schema=core_schema.chain_schema([core_schema.str_schema(), validator]),\n            python_schema=validator,\n            serialization=core_schema.to_string_ser_schema(\n                when_used=\"json-unless-none\"\n            ),\n        )\n\n    def __get_pydantic_json_schema__(\n        self,\n        core_schema_: core_schema.CoreSchema,\n        handler: pydantic.json_schema.GetJsonSchemaHandler,\n    ) -&gt; pydantic.json_schema.JsonSchemaValue:\n        \"\"\"Get the JSON schema for this type\"\"\"\n        del core_schema_\n\n        desc = \"An astropy PhysicalType expressed as a string.\"\n        return handler(core_schema.str_schema()) | {\n            \"description\": desc,\n            \"examples\": [\"length\", \"area\"],\n        }\n</code></pre>"},{"location":"api/scientific_pydantic/astropy/units/#scientific_pydantic.astropy.units.PhysicalTypeAdapter.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source_type: ty.Any, handler: pydantic.GetCoreSchemaHandler) -&gt; core_schema.CoreSchema</code>  <code>classmethod</code>","text":"<p>Get the pydantic schema for this type</p> Source code in <code>src/scientific_pydantic/astropy/units/physical_type.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls,\n    source_type: ty.Any,\n    handler: pydantic.GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Get the pydantic schema for this type\"\"\"\n    import astropy.units as u\n\n    from .validators import validate_physical_type\n\n    del handler\n\n    if source_type is not u.PhysicalType:\n        msg = (\n            \"PhysicalTypeAdapter is only usable with \"\n            f\"astropy.units.PhysicalType, not {source_type}.\"\n        )\n        raise pydantic.PydanticSchemaGenerationError(msg)\n\n    validator = core_schema.no_info_plain_validator_function(validate_physical_type)\n\n    return core_schema.json_or_python_schema(\n        json_schema=core_schema.chain_schema([core_schema.str_schema(), validator]),\n        python_schema=validator,\n        serialization=core_schema.to_string_ser_schema(\n            when_used=\"json-unless-none\"\n        ),\n    )\n</code></pre>"},{"location":"api/scientific_pydantic/astropy/units/#scientific_pydantic.astropy.units.PhysicalTypeAdapter.__get_pydantic_json_schema__","title":"<code>__get_pydantic_json_schema__(core_schema_: core_schema.CoreSchema, handler: pydantic.json_schema.GetJsonSchemaHandler) -&gt; pydantic.json_schema.JsonSchemaValue</code>","text":"<p>Get the JSON schema for this type</p> Source code in <code>src/scientific_pydantic/astropy/units/physical_type.py</code> <pre><code>def __get_pydantic_json_schema__(\n    self,\n    core_schema_: core_schema.CoreSchema,\n    handler: pydantic.json_schema.GetJsonSchemaHandler,\n) -&gt; pydantic.json_schema.JsonSchemaValue:\n    \"\"\"Get the JSON schema for this type\"\"\"\n    del core_schema_\n\n    desc = \"An astropy PhysicalType expressed as a string.\"\n    return handler(core_schema.str_schema()) | {\n        \"description\": desc,\n        \"examples\": [\"length\", \"area\"],\n    }\n</code></pre>"},{"location":"api/scientific_pydantic/astropy/units/#scientific_pydantic.astropy.units.QuantityAdapter","title":"<code>QuantityAdapter</code>","text":"<p>Pydantic type adapter for astropy.units.Quantity</p> <p>This type supports a similar API to the numpy NDArray validator, but omits dtype, as astropy.units.Quantity's are always floating point.</p> <p>Parameters:</p> Name Type Description Default <code>equivalent_unit</code> <code>UnitBase | PhysicalType | None</code> <p>If given, then quantities must have units equivalent to this.</p> <code>None</code> <code>equivalencies</code> <code>list[tuple] | None</code> <p>Optional list of astropy equivalency pairs (as returned by e.g. <code>astropy.units.spectral()</code>).  Passed verbatim to <code>UnitBase.is_equivalent</code>.</p> <code>None</code> <code>physical_type</code> <code>PhysicalType | str | Quantity | UnitBase | None</code> <p>If given, the quantity by have this physical type.</p> <code>None</code> <code>scalar</code> <code>bool</code> <p>If True, only scalar quantities will be accepted. If False, only vector quantities will be accepted. If None, no scalar constraints are enforced, unless <code>ndim</code> or <code>shape</code> are provided.</p> <code>None</code> <code>ndim</code> <code>int | None</code> <p>If given, the dimensionality of the quantity must match this value. Must be &gt;= 0.</p> <code>None</code> <code>shape</code> <code>Sequence[Ellipsis | int | range | slice | None] | None</code> <p>Shape specifier for the given array. See <code>NDArrayValidator</code> for a description of how this works.</p> <code>None</code> <code>gt</code> <code>ArrayLike | Quantity | None</code> <p>If given, all elements in the given quantity must be &gt; this value. If no units are provided, then <code>equivalent_unit</code> is used (if provided).</p> <code>None</code> <code>ge</code> <code>ArrayLike | Quantity | None</code> <p>If given, all elements in the given quantity must be &gt;= this value. If no units are provided, then <code>equivalent_unit</code> is used (if provided).</p> <code>None</code> <code>lt</code> <code>ArrayLike | Quantity | None</code> <p>If given, all elements in the given quantity must be &lt; this value. If no units are provided, then <code>equivalent_unit</code> is used (if provided).</p> <code>None</code> <code>le</code> <code>ArrayLike | Quantity | None</code> <p>If given, all elements in the given quantity must be &lt;= this value. If no units are provided, then <code>equivalent_unit</code> is used (if provided).</p> <code>None</code> <code>clip</code> <code>Sequence[ArrayLike | Quantity | None] | Quantity</code> <p>If given, a 2-element sequence of [min_clip, max_clip] to which to clip the values in the quantity. If no units are provided, then <code>equivalent_unit</code> is used (if provided).</p> <code>(None, None)</code> Source code in <code>src/scientific_pydantic/astropy/units/quantity.py</code> <pre><code>class QuantityAdapter:\n    \"\"\"Pydantic type adapter for astropy.units.Quantity\n\n    This type supports a similar API to the numpy NDArray validator, but omits\n    dtype, as astropy.units.Quantity's are always floating point.\n\n    Parameters\n    ----------\n    equivalent_unit : astropy.units.UnitBase | astropy.units.PhysicalType | None\n        If given, then quantities must have units equivalent to this.\n    equivalencies : list[tuple] | None\n        Optional list of astropy equivalency pairs (as returned by e.g.\n        ``astropy.units.spectral()``).  Passed verbatim to\n        ``UnitBase.is_equivalent``.\n    physical_type : u.PhysicalType | str | u.Quantity | u.UnitBase | None\n        If given, the quantity by have this physical type.\n    scalar : bool\n        If True, only scalar quantities will be accepted. If False, only vector\n        quantities will be accepted. If None, no scalar constraints are enforced,\n        unless `ndim` or `shape` are provided.\n    ndim : int | None\n        If given, the dimensionality of the quantity must match this value. Must\n        be &gt;= 0.\n    shape : Sequence[Ellipsis | int | range | slice | None] | None\n        Shape specifier for the given array. See `NDArrayValidator` for a\n        description of how this works.\n    gt : ArrayLike | astropy.units.Quantity | None\n        If given, all elements in the given quantity must be &gt; this value. If no\n        units are provided, then `equivalent_unit` is used (if provided).\n    ge : ArrayLike | astropy.units.Quantity | None\n        If given, all elements in the given quantity must be &gt;= this value. If no\n        units are provided, then `equivalent_unit` is used (if provided).\n    lt : ArrayLike | astropy.units.Quantity | None\n        If given, all elements in the given quantity must be &lt; this value. If no\n        units are provided, then `equivalent_unit` is used (if provided).\n    le : ArrayLike | astropy.units.Quantity | None\n        If given, all elements in the given quantity must be &lt;= this value. If no\n        units are provided, then `equivalent_unit` is used (if provided).\n    clip : Sequence[ArrayLike | u.Quantity | None] | u.Quantity\n        If given, a 2-element sequence of [min_clip, max_clip] to which to clip\n        the values in the quantity. If no units are provided, then\n        `equivalent_unit` is used (if provided).\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913, C901\n        self,\n        equivalent_unit: u.UnitBase | None = None,\n        *,\n        equivalencies: list[tuple] | None = None,\n        physical_type: u.PhysicalType | str | u.Quantity | u.UnitBase | None = None,\n        scalar: bool | None = None,\n        ndim: int | None = None,\n        shape: Sequence[types.EllipsisType | int | range | slice | None] | None = None,\n        gt: ArrayLike | u.Quantity | None = None,\n        ge: ArrayLike | u.Quantity | None = None,\n        lt: ArrayLike | u.Quantity | None = None,\n        le: ArrayLike | u.Quantity | None = None,\n        clip: Sequence[ArrayLike | u.Quantity | None] | u.Quantity = (None, None),\n        serialize_as_unit: u.UnitBase | None = None,\n    ) -&gt; None:\n        import astropy.units as u\n        import numpy as np\n\n        from scientific_pydantic.numpy.validators import (\n            NDimValidator,\n            ShapeValidator,\n            validate_all_ge,\n            validate_all_gt,\n            validate_all_le,\n            validate_all_lt,\n        )\n\n        from .validators import (\n            EquivalencyValidator,\n            PhysicalTypeValidator,\n        )\n\n        self._serialize_as_unit = serialize_as_unit\n\n        @dataclasses.dataclass\n        class CtorValidators:\n            equivalency: EquivalencyValidator | None = None\n            physical_type: PhysicalTypeValidator | None = None\n            scalar: ScalarValidator | None = None\n            ndim: NDimValidator | None = None\n            shape: ShapeValidator | None = None\n            ge: ty.Callable[[u.Quantity], u.Quantity] | None = None\n            gt: ty.Callable[[u.Quantity], u.Quantity] | None = None\n            le: ty.Callable[[u.Quantity], u.Quantity] | None = None\n            lt: ty.Callable[[u.Quantity], u.Quantity] | None = None\n            clip: ty.Callable[[u.Quantity], u.Quantity] | None = None\n\n        validators: dict[str, ty.Callable[[u.Quantity], u.Quantity]] = {}\n\n        # Handle contradictions in the shape arguments\n        if scalar is not None:\n            if scalar:\n                if ndim is not None and ndim != 0:\n                    msg = f\"scalar=True and ndim={ndim} contradict\"\n                    raise PydanticSchemaGenerationError(msg)\n                ndim = None  # ndim = 0 is redundant\n                if shape is not None and shape != ():\n                    msg = f\"scalar=True and shape={shape} contradict\"\n                    raise PydanticSchemaGenerationError(msg)\n                shape = None  # shape = () is redundant\n            else:\n                if ndim == 0:\n                    msg = \"scalar=False and ndim=0 contradict\"\n                    raise PydanticSchemaGenerationError(msg)\n                if shape == ():\n                    msg = \"scalar=False and shape=() contradict\"\n                    raise PydanticSchemaGenerationError(msg)\n            validators[\"scalar\"] = ScalarValidator(scalar=scalar)\n\n        def apply_unit_to_bound(\n            x: ArrayLike | u.Quantity | None, name: str\n        ) -&gt; u.Quantity | None:\n            if x is None:\n                return None\n            if isinstance(x, u.Quantity):\n                return x\n            if equivalent_unit is not None:\n                return x &lt;&lt; equivalent_unit\n            msg = (\n                f'If equivalent_unit is not defined, then \"{name}\" must be '\n                \"a Quantity if given\"\n            )\n            raise PydanticSchemaGenerationError(msg)\n\n        for bound, name, val in (\n            (gt, \"gt\", validate_all_gt),\n            (ge, \"ge\", validate_all_ge),\n            (lt, \"lt\", validate_all_lt),\n            (le, \"le\", validate_all_le),\n        ):\n            bound_quant = apply_unit_to_bound(bound, name)\n            if bound_quant is not None:\n                validators[name] = functools.partial(val, bound=bound_quant)\n\n        if len(clip) != 2:  # noqa: PLR2004\n            msg = f\"clip must be a sequence of size 2, was {len(clip)}\"\n            raise PydanticSchemaGenerationError(msg)\n\n        clip = (\n            apply_unit_to_bound(clip[0], \"clip[0]\"),\n            apply_unit_to_bound(clip[1], \"clip[1]\"),\n        )\n\n        def clip_val(q: u.Quantity) -&gt; u.Quantity:\n            if clip[0] is not None or clip[1] is not None:\n                return np.clip(q, clip[0], clip[1])  # type: ignore[bad-return]\n            return q\n\n        validators[\"clip\"] = clip_val\n\n        self._validators = CtorValidators(\n            equivalency=EquivalencyValidator(\n                equivalent_unit, equivalencies=equivalencies\n            )\n            if equivalent_unit is not None\n            else None,\n            physical_type=PhysicalTypeValidator(validate_physical_type(physical_type))\n            if physical_type is not None\n            else None,\n            ndim=NDimValidator(ndim=ndim) if ndim is not None else None,\n            shape=ShapeValidator(shape=shape) if shape is not None else None,\n            **validators,  # type: ignore[bad-argument-type]\n        )\n\n    def __get_pydantic_core_schema__(\n        self,\n        _source_type: ty.Any,\n        _handler: GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"Get the pydantic schema for this type\"\"\"\n        validators = [\n            core_schema.no_info_plain_validator_function(func)\n            for field in dataclasses.fields(self._validators)\n            if (func := getattr(self._validators, field.name)) is not None\n        ]\n\n        return core_schema.json_or_python_schema(\n            json_schema=core_schema.chain_schema(\n                [\n                    core_schema.no_info_plain_validator_function(_validate_quantity),\n                    *validators,\n                ],\n            ),\n            python_schema=core_schema.chain_schema(\n                [\n                    core_schema.no_info_plain_validator_function(_validate_quantity),\n                    *validators,\n                ],\n            ),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                functools.partial(\n                    _serialize, serialize_as_unit=self._serialize_as_unit\n                ),\n                info_arg=True,\n                when_used=\"unless-none\",\n            ),\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls,\n        _core_schema: core_schema.CoreSchema,\n        handler: pydantic.GetJsonSchemaHandler,\n    ) -&gt; JsonSchemaValue:\n        \"\"\"Generate JSON schema for the ndarray field\"\"\"\n        schema = handler(core_schema.any_schema())\n        schema[\"description\"] = \"An encoding of an astropy.units.Quantity\"\n        return schema\n</code></pre>"},{"location":"api/scientific_pydantic/astropy/units/#scientific_pydantic.astropy.units.QuantityAdapter.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(_source_type: ty.Any, _handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema</code>","text":"<p>Get the pydantic schema for this type</p> Source code in <code>src/scientific_pydantic/astropy/units/quantity.py</code> <pre><code>def __get_pydantic_core_schema__(\n    self,\n    _source_type: ty.Any,\n    _handler: GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Get the pydantic schema for this type\"\"\"\n    validators = [\n        core_schema.no_info_plain_validator_function(func)\n        for field in dataclasses.fields(self._validators)\n        if (func := getattr(self._validators, field.name)) is not None\n    ]\n\n    return core_schema.json_or_python_schema(\n        json_schema=core_schema.chain_schema(\n            [\n                core_schema.no_info_plain_validator_function(_validate_quantity),\n                *validators,\n            ],\n        ),\n        python_schema=core_schema.chain_schema(\n            [\n                core_schema.no_info_plain_validator_function(_validate_quantity),\n                *validators,\n            ],\n        ),\n        serialization=core_schema.plain_serializer_function_ser_schema(\n            functools.partial(\n                _serialize, serialize_as_unit=self._serialize_as_unit\n            ),\n            info_arg=True,\n            when_used=\"unless-none\",\n        ),\n    )\n</code></pre>"},{"location":"api/scientific_pydantic/astropy/units/#scientific_pydantic.astropy.units.QuantityAdapter.__get_pydantic_json_schema__","title":"<code>__get_pydantic_json_schema__(_core_schema: core_schema.CoreSchema, handler: pydantic.GetJsonSchemaHandler) -&gt; JsonSchemaValue</code>  <code>classmethod</code>","text":"<p>Generate JSON schema for the ndarray field</p> Source code in <code>src/scientific_pydantic/astropy/units/quantity.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    _core_schema: core_schema.CoreSchema,\n    handler: pydantic.GetJsonSchemaHandler,\n) -&gt; JsonSchemaValue:\n    \"\"\"Generate JSON schema for the ndarray field\"\"\"\n    schema = handler(core_schema.any_schema())\n    schema[\"description\"] = \"An encoding of an astropy.units.Quantity\"\n    return schema\n</code></pre>"},{"location":"api/scientific_pydantic/astropy/units/#scientific_pydantic.astropy.units.UnitAdapter","title":"<code>UnitAdapter</code>","text":"<p>A pydantic adapter for astropy units</p> <p>Parameters:</p> Name Type Description Default <code>equivalent_unit</code> <code>UnitBase | str | None</code> <p>If given, validated values must be equivalent to this unit.</p> <code>None</code> <code>equivalencies</code> <code>list[tuple] | None</code> <p>Optional list of astropy equivalency pairs (as returned by e.g. <code>astropy.units.spectral()</code>).  Passed verbatim to <code>UnitBase.is_equivalent</code>.</p> <code>None</code> <code>physical_type</code> <code>PhysicalType | str | Quantity | UnitBase | None</code> <p>If given, the unit by have this physical type</p> <code>None</code> Source code in <code>src/scientific_pydantic/astropy/units/unit.py</code> <pre><code>class UnitAdapter:\n    \"\"\"A pydantic adapter for astropy units\n\n    Parameters\n    ----------\n    equivalent_unit : astropy.units.UnitBase | str | None\n        If given, validated values must be equivalent to this unit.\n    equivalencies:\n        Optional list of astropy equivalency pairs (as returned by e.g.\n        ``astropy.units.spectral()``).  Passed verbatim to\n        ``UnitBase.is_equivalent``.\n    physical_type : u.PhysicalType | str | u.Quantity | u.UnitBase | None\n        If given, the unit by have this physical type\n    \"\"\"\n\n    def __init__(\n        self,\n        equivalent_unit: u.UnitBase | str | None = None,\n        *,\n        equivalencies: list[tuple] | None = None,\n        physical_type: u.PhysicalType | str | u.Quantity | u.UnitBase | None = None,\n    ) -&gt; None:\n        from .validators import (\n            EquivalencyValidator,\n            PhysicalTypeValidator,\n            validate_physical_type,\n        )\n\n        @dataclasses.dataclass\n        class Validators:\n            equivalency: EquivalencyValidator | None = None\n            physical_type: PhysicalTypeValidator | None = None\n\n        validators: dict[str, ty.Any] = {}\n\n        if equivalent_unit is not None:\n            validators[\"equivalency\"] = EquivalencyValidator(\n                equivalent_unit, equivalencies=equivalencies\n            )\n\n        if physical_type is not None:\n            validators[\"physical_type\"] = PhysicalTypeValidator(\n                validate_physical_type(physical_type)\n            )\n        self._validators = Validators(**validators)\n\n    @property\n    def equivalent_unit(self) -&gt; u.UnitBase | None:\n        \"\"\"If non-None, validated units must be equivalent to this unit\"\"\"\n        val = self._validators.equivalency\n        return val.equivalent_unit if val is not None else None\n\n    @property\n    def equivalencies(self) -&gt; list[tuple] | None:\n        \"\"\"Custom equivalencies for the equivalency check\"\"\"\n        val = self._validators.equivalency\n        return val.equivalencies if val is not None else None\n\n    @property\n    def physical_type(self) -&gt; u.PhysicalType | None:\n        \"\"\"If non-None, validated unit must be of this physical type\"\"\"\n        val = self._validators.physical_type\n        return val.physical_type if val is not None else None\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: ty.Any,\n        handler: pydantic.GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"Get the pydantic schema for this type\"\"\"\n        import astropy.units as u\n\n        from .validators import validate_unit\n\n        del handler\n\n        if source_type is not u.UnitBase:\n            msg = (\n                \"UnitAdapter is only usable with \"\n                f\"astropy.units.UnitBase, not {source_type}.\"\n            )\n            raise pydantic.PydanticSchemaGenerationError(msg)\n\n        validators: list[core_schema.CoreSchema] = [\n            core_schema.no_info_plain_validator_function(validate_unit)\n        ]\n        if (equiv_val := self._validators.equivalency) is not None:\n            validators.append(core_schema.no_info_plain_validator_function(equiv_val))\n        if (pt_val := self._validators.physical_type) is not None:\n            validators.append(core_schema.no_info_plain_validator_function(pt_val))\n\n        return core_schema.json_or_python_schema(\n            json_schema=core_schema.chain_schema(\n                [core_schema.str_schema(), *validators]\n            ),\n            python_schema=core_schema.chain_schema(validators),\n            serialization=core_schema.to_string_ser_schema(),\n        )\n\n    def __get_pydantic_json_schema__(\n        self,\n        core_schema_: core_schema.CoreSchema,\n        handler: pydantic.json_schema.GetJsonSchemaHandler,\n    ) -&gt; pydantic.json_schema.JsonSchemaValue:\n        \"\"\"Get the JSON schema for this type\"\"\"\n        del core_schema_\n\n        desc = \"An astropy unit expressed as a string.\"\n        if self.equivalent_unit is not None:\n            equiv_hint = \"\"\n            if self.equivalencies is not None:\n                equiv_hint = (\n                    \" (with custom equivalencies: \"\n                    + \", \".join(f\"{x[0]} &lt;-&gt; {x[1]}\" for x in self.equivalencies)\n                    + \")\"\n                )\n            desc += f' Must be equivalent to \"{self.equivalent_unit}\"{equiv_hint}.'\n        if self.physical_type is not None:\n            desc += f' Must be of type \"{self.physical_type!s}\".'\n\n        return handler(core_schema.str_schema()) | {\n            \"description\": desc,\n            \"examples\": [\"m / s\", \"km / h\", \"kg\", \"deg\", \"J / (kg K)\"]\n            if self.equivalent_unit is None\n            else [str(self.equivalent_unit)],\n        }\n</code></pre>"},{"location":"api/scientific_pydantic/astropy/units/#scientific_pydantic.astropy.units.UnitAdapter.equivalent_unit","title":"<code>equivalent_unit: u.UnitBase | None</code>  <code>property</code>","text":"<p>If non-None, validated units must be equivalent to this unit</p>"},{"location":"api/scientific_pydantic/astropy/units/#scientific_pydantic.astropy.units.UnitAdapter.equivalencies","title":"<code>equivalencies: list[tuple] | None</code>  <code>property</code>","text":"<p>Custom equivalencies for the equivalency check</p>"},{"location":"api/scientific_pydantic/astropy/units/#scientific_pydantic.astropy.units.UnitAdapter.physical_type","title":"<code>physical_type: u.PhysicalType | None</code>  <code>property</code>","text":"<p>If non-None, validated unit must be of this physical type</p>"},{"location":"api/scientific_pydantic/astropy/units/#scientific_pydantic.astropy.units.UnitAdapter.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source_type: ty.Any, handler: pydantic.GetCoreSchemaHandler) -&gt; core_schema.CoreSchema</code>","text":"<p>Get the pydantic schema for this type</p> Source code in <code>src/scientific_pydantic/astropy/units/unit.py</code> <pre><code>def __get_pydantic_core_schema__(\n    self,\n    source_type: ty.Any,\n    handler: pydantic.GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Get the pydantic schema for this type\"\"\"\n    import astropy.units as u\n\n    from .validators import validate_unit\n\n    del handler\n\n    if source_type is not u.UnitBase:\n        msg = (\n            \"UnitAdapter is only usable with \"\n            f\"astropy.units.UnitBase, not {source_type}.\"\n        )\n        raise pydantic.PydanticSchemaGenerationError(msg)\n\n    validators: list[core_schema.CoreSchema] = [\n        core_schema.no_info_plain_validator_function(validate_unit)\n    ]\n    if (equiv_val := self._validators.equivalency) is not None:\n        validators.append(core_schema.no_info_plain_validator_function(equiv_val))\n    if (pt_val := self._validators.physical_type) is not None:\n        validators.append(core_schema.no_info_plain_validator_function(pt_val))\n\n    return core_schema.json_or_python_schema(\n        json_schema=core_schema.chain_schema(\n            [core_schema.str_schema(), *validators]\n        ),\n        python_schema=core_schema.chain_schema(validators),\n        serialization=core_schema.to_string_ser_schema(),\n    )\n</code></pre>"},{"location":"api/scientific_pydantic/astropy/units/#scientific_pydantic.astropy.units.UnitAdapter.__get_pydantic_json_schema__","title":"<code>__get_pydantic_json_schema__(core_schema_: core_schema.CoreSchema, handler: pydantic.json_schema.GetJsonSchemaHandler) -&gt; pydantic.json_schema.JsonSchemaValue</code>","text":"<p>Get the JSON schema for this type</p> Source code in <code>src/scientific_pydantic/astropy/units/unit.py</code> <pre><code>def __get_pydantic_json_schema__(\n    self,\n    core_schema_: core_schema.CoreSchema,\n    handler: pydantic.json_schema.GetJsonSchemaHandler,\n) -&gt; pydantic.json_schema.JsonSchemaValue:\n    \"\"\"Get the JSON schema for this type\"\"\"\n    del core_schema_\n\n    desc = \"An astropy unit expressed as a string.\"\n    if self.equivalent_unit is not None:\n        equiv_hint = \"\"\n        if self.equivalencies is not None:\n            equiv_hint = (\n                \" (with custom equivalencies: \"\n                + \", \".join(f\"{x[0]} &lt;-&gt; {x[1]}\" for x in self.equivalencies)\n                + \")\"\n            )\n        desc += f' Must be equivalent to \"{self.equivalent_unit}\"{equiv_hint}.'\n    if self.physical_type is not None:\n        desc += f' Must be of type \"{self.physical_type!s}\".'\n\n    return handler(core_schema.str_schema()) | {\n        \"description\": desc,\n        \"examples\": [\"m / s\", \"km / h\", \"kg\", \"deg\", \"J / (kg K)\"]\n        if self.equivalent_unit is None\n        else [str(self.equivalent_unit)],\n    }\n</code></pre>"},{"location":"api/scientific_pydantic/numpy/","title":"<code>numpy</code>","text":"<pre><code>import scientific_pydantic.numpy\n</code></pre>"},{"location":"api/scientific_pydantic/numpy/#scientific_pydantic.numpy","title":"<code>numpy</code>","text":"<p>Numpy adaptors</p>"},{"location":"api/scientific_pydantic/numpy/#scientific_pydantic.numpy.DTypeAdapter","title":"<code>DTypeAdapter</code>","text":"<p>Pydantic adapter for numpy.dtype</p> <p>Runtime value: numpy.dtype JSON representation: dtype.str (e.g. '&lt;f8', '|i4')</p> Source code in <code>src/scientific_pydantic/numpy/dtype_adapter.py</code> <pre><code>class DTypeAdapter:\n    \"\"\"Pydantic adapter for numpy.dtype\n\n    Runtime value: numpy.dtype\n    JSON representation: dtype.str (e.g. '&lt;f8', '|i4')\n    \"\"\"\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source_type: type[ty.Any],\n        _handler: pydantic.GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"Get the pydantic schema for this type\"\"\"\n        return core_schema.no_info_plain_validator_function(\n            cls._validate,\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                cls._serialize,\n            ),\n        )\n\n    @staticmethod\n    def _validate(value: ty.Any) -&gt; \"np.dtype\":\n        import numpy as np\n\n        if isinstance(value, np.dtype):\n            return value\n\n        try:\n            return np.dtype(value)\n        except Exception as exc:\n            msg = f\"Invalid numpy dtype: {value!r}\"\n            raise ValueError(msg) from exc\n\n    @staticmethod\n    def _serialize(value: \"np.dtype\") -&gt; str:\n        return value.str\n\n    def __get_pydantic_json_schema__(\n        self,\n        _core_schema: core_schema.CoreSchema,\n        _handler: pydantic.GetJsonSchemaHandler,\n    ) -&gt; JsonSchemaValue:\n        \"\"\"Generate JSON schema for the ndarray field\"\"\"\n        json_schema = ty.cast(\"dict\", core_schema.str_schema())\n        json_schema[\"description\"] = \"NumPy dtype\"\n        return ty.cast(\"JsonSchemaValue\", json_schema)\n</code></pre>"},{"location":"api/scientific_pydantic/numpy/#scientific_pydantic.numpy.DTypeAdapter.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(_source_type: type[ty.Any], _handler: pydantic.GetCoreSchemaHandler) -&gt; core_schema.CoreSchema</code>  <code>classmethod</code>","text":"<p>Get the pydantic schema for this type</p> Source code in <code>src/scientific_pydantic/numpy/dtype_adapter.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls,\n    _source_type: type[ty.Any],\n    _handler: pydantic.GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Get the pydantic schema for this type\"\"\"\n    return core_schema.no_info_plain_validator_function(\n        cls._validate,\n        serialization=core_schema.plain_serializer_function_ser_schema(\n            cls._serialize,\n        ),\n    )\n</code></pre>"},{"location":"api/scientific_pydantic/numpy/#scientific_pydantic.numpy.DTypeAdapter.__get_pydantic_json_schema__","title":"<code>__get_pydantic_json_schema__(_core_schema: core_schema.CoreSchema, _handler: pydantic.GetJsonSchemaHandler) -&gt; JsonSchemaValue</code>","text":"<p>Generate JSON schema for the ndarray field</p> Source code in <code>src/scientific_pydantic/numpy/dtype_adapter.py</code> <pre><code>def __get_pydantic_json_schema__(\n    self,\n    _core_schema: core_schema.CoreSchema,\n    _handler: pydantic.GetJsonSchemaHandler,\n) -&gt; JsonSchemaValue:\n    \"\"\"Generate JSON schema for the ndarray field\"\"\"\n    json_schema = ty.cast(\"dict\", core_schema.str_schema())\n    json_schema[\"description\"] = \"NumPy dtype\"\n    return ty.cast(\"JsonSchemaValue\", json_schema)\n</code></pre>"},{"location":"api/scientific_pydantic/numpy/#scientific_pydantic.numpy.NDArrayAdapter","title":"<code>NDArrayAdapter</code>","text":"<p>Pydantic type adapter for numpy ndarrays with validation constraints.</p> <p>Usage:     class MyModel(BaseModel):         field: Annotated[             np.ndarray,             NDArrayAdapter(shape=(3, None), dtype=float)         ]</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>type | dtype | str | None</code> <code>None</code> <code>ndim</code> <code>int | None</code> <code>None</code> <code>shape</code> <code>Sequence[EllipsisType | int | range | slice | None] | None</code> <code>None</code> <code>gt</code> <code>float | None</code> <code>None</code> <code>ge</code> <code>float | None</code> <code>None</code> <code>lt</code> <code>float | None</code> <code>None</code> <code>le</code> <code>float | None</code> <code>None</code> <code>clip</code> <code>tuple[float | None, float | None]</code> <code>(None, None)</code> Source code in <code>src/scientific_pydantic/numpy/ndarray_adapter.py</code> <pre><code>class NDArrayAdapter:\n    \"\"\"Pydantic type adapter for numpy ndarrays with validation constraints.\n\n    Usage:\n        class MyModel(BaseModel):\n            field: Annotated[\n                np.ndarray,\n                NDArrayAdapter(shape=(3, None), dtype=float)\n            ]\n\n    Parameters\n    ----------\n    dtype: \"type | np.dtype | str | None\" = None,\n    ndim: int | None = None,\n    shape: Sequence[Ellipsis | int | range | slice | None] | None = None,\n    gt: float | None = None,\n    ge: float | None = None,\n    lt: float | None = None,\n    le: float | None = None,\n    clip: tuple[float | None, float | None] = (None, None),\n    \"\"\"\n\n    def __init__(  # noqa: PLR0913\n        self,\n        *,\n        dtype: \"type | np.dtype | str | None\" = None,\n        ndim: int | None = None,\n        shape: Sequence[types.EllipsisType | int | range | slice | None] | None = None,\n        gt: float | None = None,\n        ge: float | None = None,\n        lt: float | None = None,\n        le: float | None = None,\n        clip: tuple[float | None, float | None] = (None, None),\n    ) -&gt; None:\n        from .validators import NDArrayValidator\n\n        self._validator = NDArrayValidator.from_kwargs(\n            dtype=dtype,\n            ndim=ndim,\n            shape=shape,\n            gt=gt,\n            ge=ge,\n            lt=lt,\n            le=le,\n            clip=clip,\n        )\n\n    def __get_pydantic_core_schema__(\n        self,\n        _source_type: ty.Any,\n        _handler: pydantic.GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"Get the pydantic schema for an NDArray\"\"\"\n        import numpy as np\n\n        def validate(value: ty.Any) -&gt; np.typing.NDArray:\n            return self._validator(value)\n\n        def serialize(value: np.typing.NDArray) -&gt; list:\n            \"\"\"Serialize ndarray to nested lists for JSON\"\"\"\n            return value.tolist()\n\n        python_schema = core_schema.no_info_after_validator_function(\n            validate,\n            core_schema.any_schema(),\n        )\n\n        return core_schema.json_or_python_schema(\n            json_schema=core_schema.chain_schema(\n                [\n                    core_schema.any_schema(),\n                    core_schema.no_info_after_validator_function(\n                        validate,\n                        core_schema.any_schema(),\n                    ),\n                ],\n            ),\n            python_schema=python_schema,\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                serialize,\n                info_arg=False,\n                return_schema=core_schema.any_schema(),\n            ),\n        )\n\n    def __get_pydantic_json_schema__(  # noqa: C901\n        self,\n        _core_schema: core_schema.CoreSchema,\n        _handler: pydantic.GetJsonSchemaHandler,\n    ) -&gt; JsonSchemaValue:\n        \"\"\"Generate JSON schema for the ndarray field\"\"\"\n        json_schema: dict[str, ty.Any] = {\"type\": \"array\"}\n\n        # Add description of constraints\n        constraints = []\n        if self._validator.dtype is not None:\n            constraints.append(f\"dtype: {self._validator.dtype.dtype}\")\n\n        ndim = self._validator.ndim.ndim if self._validator.ndim is not None else None\n        if ndim is not None:\n            constraints.append(f\"{ndim}D array\")\n        if self._validator.shape is not None:\n            shape_desc = \"x\".join(\n                str(s) if s is not None else \"?\" for s in self._validator.shape.shape\n            )\n            constraints.append(f\"shape: ({shape_desc})\")\n        if self._validator.ge is not None:\n            constraints.append(f\"values &gt;= {self._validator.ge.ge}\")\n        if self._validator.le is not None:\n            constraints.append(f\"values &lt;= {self._validator.le.le}\")\n        if self._validator.gt is not None:\n            constraints.append(f\"values &gt; {self._validator.gt.gt}\")\n        if self._validator.lt is not None:\n            constraints.append(f\"values &lt; {self._validator.lt.lt}\")\n        if self._validator.clip is not None:\n            constraints.append(\n                f\"clipped to [{self._validator.clip.clip[0]}, \"\n                f\"{self._validator.clip.clip[1]}]\",\n            )\n\n        if constraints:\n            json_schema[\"description\"] = \"NumPy array: \" + \", \".join(constraints)\n\n        # Add items constraint based on ndim\n        if ndim is not None and ndim &lt;= 1:\n            json_schema[\"items\"] = {\"type\": \"number\"}\n        elif ndim is not None and ndim &gt; 1:\n            # Nested arrays\n            items_schema = {\"type\": \"number\"}\n            for _ in range(ndim - 1):\n                items_schema = {\"type\": \"array\", \"items\": items_schema}\n            json_schema[\"items\"] = items_schema\n\n        return json_schema\n</code></pre>"},{"location":"api/scientific_pydantic/numpy/#scientific_pydantic.numpy.NDArrayAdapter.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(_source_type: ty.Any, _handler: pydantic.GetCoreSchemaHandler) -&gt; core_schema.CoreSchema</code>","text":"<p>Get the pydantic schema for an NDArray</p> Source code in <code>src/scientific_pydantic/numpy/ndarray_adapter.py</code> <pre><code>def __get_pydantic_core_schema__(\n    self,\n    _source_type: ty.Any,\n    _handler: pydantic.GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Get the pydantic schema for an NDArray\"\"\"\n    import numpy as np\n\n    def validate(value: ty.Any) -&gt; np.typing.NDArray:\n        return self._validator(value)\n\n    def serialize(value: np.typing.NDArray) -&gt; list:\n        \"\"\"Serialize ndarray to nested lists for JSON\"\"\"\n        return value.tolist()\n\n    python_schema = core_schema.no_info_after_validator_function(\n        validate,\n        core_schema.any_schema(),\n    )\n\n    return core_schema.json_or_python_schema(\n        json_schema=core_schema.chain_schema(\n            [\n                core_schema.any_schema(),\n                core_schema.no_info_after_validator_function(\n                    validate,\n                    core_schema.any_schema(),\n                ),\n            ],\n        ),\n        python_schema=python_schema,\n        serialization=core_schema.plain_serializer_function_ser_schema(\n            serialize,\n            info_arg=False,\n            return_schema=core_schema.any_schema(),\n        ),\n    )\n</code></pre>"},{"location":"api/scientific_pydantic/numpy/#scientific_pydantic.numpy.NDArrayAdapter.__get_pydantic_json_schema__","title":"<code>__get_pydantic_json_schema__(_core_schema: core_schema.CoreSchema, _handler: pydantic.GetJsonSchemaHandler) -&gt; JsonSchemaValue</code>","text":"<p>Generate JSON schema for the ndarray field</p> Source code in <code>src/scientific_pydantic/numpy/ndarray_adapter.py</code> <pre><code>def __get_pydantic_json_schema__(  # noqa: C901\n    self,\n    _core_schema: core_schema.CoreSchema,\n    _handler: pydantic.GetJsonSchemaHandler,\n) -&gt; JsonSchemaValue:\n    \"\"\"Generate JSON schema for the ndarray field\"\"\"\n    json_schema: dict[str, ty.Any] = {\"type\": \"array\"}\n\n    # Add description of constraints\n    constraints = []\n    if self._validator.dtype is not None:\n        constraints.append(f\"dtype: {self._validator.dtype.dtype}\")\n\n    ndim = self._validator.ndim.ndim if self._validator.ndim is not None else None\n    if ndim is not None:\n        constraints.append(f\"{ndim}D array\")\n    if self._validator.shape is not None:\n        shape_desc = \"x\".join(\n            str(s) if s is not None else \"?\" for s in self._validator.shape.shape\n        )\n        constraints.append(f\"shape: ({shape_desc})\")\n    if self._validator.ge is not None:\n        constraints.append(f\"values &gt;= {self._validator.ge.ge}\")\n    if self._validator.le is not None:\n        constraints.append(f\"values &lt;= {self._validator.le.le}\")\n    if self._validator.gt is not None:\n        constraints.append(f\"values &gt; {self._validator.gt.gt}\")\n    if self._validator.lt is not None:\n        constraints.append(f\"values &lt; {self._validator.lt.lt}\")\n    if self._validator.clip is not None:\n        constraints.append(\n            f\"clipped to [{self._validator.clip.clip[0]}, \"\n            f\"{self._validator.clip.clip[1]}]\",\n        )\n\n    if constraints:\n        json_schema[\"description\"] = \"NumPy array: \" + \", \".join(constraints)\n\n    # Add items constraint based on ndim\n    if ndim is not None and ndim &lt;= 1:\n        json_schema[\"items\"] = {\"type\": \"number\"}\n    elif ndim is not None and ndim &gt; 1:\n        # Nested arrays\n        items_schema = {\"type\": \"number\"}\n        for _ in range(ndim - 1):\n            items_schema = {\"type\": \"array\", \"items\": items_schema}\n        json_schema[\"items\"] = items_schema\n\n    return json_schema\n</code></pre>"},{"location":"api/scientific_pydantic/scipy/","title":"<code>scipy</code>","text":"<pre><code>import scientific_pydantic.scipy\n</code></pre> <p>See subpackages below.</p>"},{"location":"api/scientific_pydantic/scipy/spatial/","title":"<code>spatial</code>","text":"<pre><code>import scientific_pydantic.scipy.spatial\n</code></pre> <p>See subpackages below.</p>"},{"location":"api/scientific_pydantic/scipy/spatial/transform/","title":"<code>transform</code>","text":"<pre><code>import scientific_pydantic.scipy.spatial.transform\n</code></pre>"},{"location":"api/scientific_pydantic/scipy/spatial/transform/#scientific_pydantic.scipy.spatial.transform","title":"<code>transform</code>","text":"<p>Pydantic adapters for scipy.spatial.rotation</p>"},{"location":"api/scientific_pydantic/scipy/spatial/transform/#scientific_pydantic.scipy.spatial.transform.RotationAdapter","title":"<code>RotationAdapter</code>","text":"<p>Pydantic adapter for scipy.spatial.transform.Rotation.</p> <p>Serializes a Rotation as a quaternion (scalar-last, xyzw convention - the same convention scipy uses internally) and validates from: - A Rotation instance (passthrough) - A mapping with one of the following:   - {       \"quat\": array_like, shape (..., 4),       \"scalar_first\": bool (default False),     }   - {       \"matrix\": array_like, shape (..., 3, 3),       \"assume_valid\": bool (default False, requires &gt;= 1.17.0),     }   - {       \"rotvec\": array_like, shape (..., 3),       \"degrees\": bool (default False),     }   - {       \"mrp\": array_like, shape (..., 3),     }   - {       \"euler\": {         \"seq\": str (see scipy docs),         \"angles\": float | array_like, shape (..., [1 or 2 or 3]),         \"degrees\": bool (default False),       },     }   - {       \"davenport\": {         \"axes\": array_like, shape (3,) or (..., [1 or 2 or 3], 3),         \"order\": \"e\" or \"extrinsic\" or \"i\" or \"intrinsic\"         \"angles\": float | array_like, shape (..., [1 or 2 or 3]),         \"degrees\": bool (default False),       }     }</p> Usage <pre><code>import typing as ty\nfrom pydantic import BaseModel\nfrom scientific_pydantic.scipy.spatial.transform import RotationAdapter\nfrom scipy.spatial.transform import Rotation\n\nclass Pose(BaseModel):\n    rotation: ty.Annotated[Rotation, RotationAdapter()]\n\npose = Pose(rotation={\"quat\": [0, 0, 0, 1]})\npose.rotation          # scipy.spatial.transform.Rotation instance\npose.model_dump()      # {\"rotation\": {\"quat\": [0.0, 0.0, 0.0, 1.0]}}\npose.model_dump_json() # '{\"rotation\":{\"quat\":[0.0,0.0,0.0,1.0]}}'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>single</code> <code>bool | None</code> <p>If given as <code>True</code>, only single rotations will be accepted. Overrides <code>ndim</code> or <code>shape</code>.</p> <code>None</code> <code>ndim</code> <code>int | None</code> <p>If given, the dimensionaly of the rotations must be equal to the given value.</p> <code>None</code> <code>shape</code> <code>Sequence[int | range | slice | None] | None</code> <p>If given, provides a constraint on the shape of the given rotations. Overrides <code>ndim</code>.</p> <code>None</code> Source code in <code>src/scientific_pydantic/scipy/spatial/transform/rotation.py</code> <pre><code>class RotationAdapter:\n    \"\"\"Pydantic adapter for scipy.spatial.transform.Rotation.\n\n    Serializes a Rotation as a quaternion (scalar-last, xyzw convention -\n    the same convention scipy uses internally) and validates from:\n    - A Rotation instance (passthrough)\n    - A mapping with one of the following:\n      - {\n          \"quat\": array_like, shape (..., 4),\n          \"scalar_first\": bool (default False),\n        }\n      - {\n          \"matrix\": array_like, shape (..., 3, 3),\n          \"assume_valid\": bool (default False, requires &gt;= 1.17.0),\n        }\n      - {\n          \"rotvec\": array_like, shape (..., 3),\n          \"degrees\": bool (default False),\n        }\n      - {\n          \"mrp\": array_like, shape (..., 3),\n        }\n      - {\n          \"euler\": {\n            \"seq\": str (see scipy docs),\n            \"angles\": float | array_like, shape (..., [1 or 2 or 3]),\n            \"degrees\": bool (default False),\n          },\n        }\n      - {\n          \"davenport\": {\n            \"axes\": array_like, shape (3,) or (..., [1 or 2 or 3], 3),\n            \"order\": \"e\" or \"extrinsic\" or \"i\" or \"intrinsic\"\n            \"angles\": float | array_like, shape (..., [1 or 2 or 3]),\n            \"degrees\": bool (default False),\n          }\n        }\n\n    Usage\n    -----\n        import typing as ty\n        from pydantic import BaseModel\n        from scientific_pydantic.scipy.spatial.transform import RotationAdapter\n        from scipy.spatial.transform import Rotation\n\n        class Pose(BaseModel):\n            rotation: ty.Annotated[Rotation, RotationAdapter()]\n\n        pose = Pose(rotation={\"quat\": [0, 0, 0, 1]})\n        pose.rotation          # scipy.spatial.transform.Rotation instance\n        pose.model_dump()      # {\"rotation\": {\"quat\": [0.0, 0.0, 0.0, 1.0]}}\n        pose.model_dump_json() # '{\"rotation\":{\"quat\":[0.0,0.0,0.0,1.0]}}'\n\n    Parameters\n    ----------\n    single : bool | None\n        If given as `True`, only single rotations will be accepted. Overrides\n        `ndim` or `shape`.\n    ndim : int | None\n        If given, the dimensionaly of the rotations must be equal to the given\n        value.\n    shape : Sequence[int | range | slice | None] | None\n        If given, provides a constraint on the shape of the given rotations.\n        Overrides `ndim`.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        single: bool | None = None,\n        ndim: int | None = None,\n        shape: Sequence[EllipsisLiteral | int | range | slice | None] | None = None,\n    ) -&gt; None:\n\n        self._shape_spec: (\n            Sequence[types.EllipsisType | int | range | slice | None] | None\n        ) = None\n        if single:\n            self._shape_spec = ()\n        elif shape is not None:\n            self._shape_spec = shape\n        elif ndim is not None:\n            self._shape_spec = (None,) * ndim\n\n        if not _supports_shape() and (\n            (shape is not None and len(shape) &gt; 1)\n            or (ndim is not None and ndim not in (0, 1))\n        ):\n            msg = \"N-D shape constraints on Rotation require scipy &gt;= 1.17.0\"\n            raise pydantic.PydanticSchemaGenerationError(msg)\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: ty.Any,\n        handler: GetCoreSchemaHandler,\n    ) -&gt; CoreSchema:\n        \"\"\"Get the pydantic schema for this type\"\"\"\n        from scipy.spatial.transform import Rotation\n\n        del handler\n\n        if source_type is not Rotation:\n            msg = (\n                \"RotationAdapter is only usable with \"\n                f\"scipy.spatial.transform.Rotation, not {source_type}.\"\n            )\n            raise pydantic.PydanticSchemaGenerationError(msg)\n\n        # Accept any Python object and run our validator.\n        python_schema = core_schema.no_info_plain_validator_function(\n            _validate_rotation,\n        )\n        if self._shape_spec is not None:\n            spec = self._shape_spec\n\n            def _val(x: Rotation) -&gt; Rotation:\n                shape = (\n                    x.shape if _supports_shape() else (() if x.single else (len(x),))\n                )\n                if validate_shape(shape, spec):\n                    return x\n\n                err_t = \"invalid_rotation_shape\"\n                msg = \"Rotation object shape {shape} did not match spec {spec}\"\n                raise PydanticCustomError(err_t, msg, {\"shape\": shape, \"spec\": spec})\n\n            python_schema = core_schema.chain_schema(\n                [\n                    python_schema,\n                    core_schema.no_info_plain_validator_function(_val),\n                ]\n            )\n\n        # When deserialising from JSON/dict Pydantic passes a Python object\n        # after JSON parsing, so the same validator works for both paths.\n        return core_schema.json_or_python_schema(\n            json_schema=python_schema,\n            python_schema=python_schema,\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                _rotation_to_dict,\n                when_used=\"json-unless-none\",\n                return_schema=core_schema.dict_schema(),\n            ),\n        )\n</code></pre>"},{"location":"api/scientific_pydantic/scipy/spatial/transform/#scientific_pydantic.scipy.spatial.transform.RotationAdapter.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source_type: ty.Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema</code>","text":"<p>Get the pydantic schema for this type</p> Source code in <code>src/scientific_pydantic/scipy/spatial/transform/rotation.py</code> <pre><code>def __get_pydantic_core_schema__(\n    self,\n    source_type: ty.Any,\n    handler: GetCoreSchemaHandler,\n) -&gt; CoreSchema:\n    \"\"\"Get the pydantic schema for this type\"\"\"\n    from scipy.spatial.transform import Rotation\n\n    del handler\n\n    if source_type is not Rotation:\n        msg = (\n            \"RotationAdapter is only usable with \"\n            f\"scipy.spatial.transform.Rotation, not {source_type}.\"\n        )\n        raise pydantic.PydanticSchemaGenerationError(msg)\n\n    # Accept any Python object and run our validator.\n    python_schema = core_schema.no_info_plain_validator_function(\n        _validate_rotation,\n    )\n    if self._shape_spec is not None:\n        spec = self._shape_spec\n\n        def _val(x: Rotation) -&gt; Rotation:\n            shape = (\n                x.shape if _supports_shape() else (() if x.single else (len(x),))\n            )\n            if validate_shape(shape, spec):\n                return x\n\n            err_t = \"invalid_rotation_shape\"\n            msg = \"Rotation object shape {shape} did not match spec {spec}\"\n            raise PydanticCustomError(err_t, msg, {\"shape\": shape, \"spec\": spec})\n\n        python_schema = core_schema.chain_schema(\n            [\n                python_schema,\n                core_schema.no_info_plain_validator_function(_val),\n            ]\n        )\n\n    # When deserialising from JSON/dict Pydantic passes a Python object\n    # after JSON parsing, so the same validator works for both paths.\n    return core_schema.json_or_python_schema(\n        json_schema=python_schema,\n        python_schema=python_schema,\n        serialization=core_schema.plain_serializer_function_ser_schema(\n            _rotation_to_dict,\n            when_used=\"json-unless-none\",\n            return_schema=core_schema.dict_schema(),\n        ),\n    )\n</code></pre>"},{"location":"api/scientific_pydantic/shapely/","title":"<code>shapely</code>","text":"<pre><code>import scientific_pydantic.shapely\n</code></pre>"},{"location":"api/scientific_pydantic/shapely/#scientific_pydantic.shapely","title":"<code>shapely</code>","text":"<p>Type adaptors for shapely</p>"},{"location":"api/scientific_pydantic/shapely/#scientific_pydantic.shapely.GeometryAdapter","title":"<code>GeometryAdapter</code>","text":"<p>A pydantic adapter for shapely geometry</p> Source code in <code>src/scientific_pydantic/shapely/adapters.py</code> <pre><code>class GeometryAdapter:\n    \"\"\"A pydantic adapter for shapely geometry\"\"\"\n\n    CoordinateBounds: ty.ClassVar[type] = GeometryConstraints.CoordinateBounds\n\n    def __init__(\n        self,\n        *,\n        dimensionality: ty.Literal[2, 3] | None = None,\n        x_bounds: CoordinateBounds | None = None,\n        y_bounds: CoordinateBounds | None = None,\n        z_bounds: CoordinateBounds | None = None,\n    ) -&gt; None:\n        self._validator = GeometryConstraints(\n            dimensionality=dimensionality,\n            x_bounds=x_bounds,\n            y_bounds=y_bounds,\n            z_bounds=z_bounds,\n        )\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: ty.Any,\n        _handler: pydantic.GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"Get the pydantic schema for the shapely geometry\"\"\"\n        import shapely\n\n        allowable_types = _get_allowable_types(source_type)\n\n        def validate(value: ty.Any) -&gt; ty.Any:\n            if isinstance(value, shapely.geometry.base.BaseGeometry):\n                pass\n            elif isinstance(value, str):\n                value = _parse_str(value)\n            elif (is_mapping := isinstance(value, Mapping)) or hasattr(\n                value, \"__geo_interface__\"\n            ):\n                # shapely raises an AttributeError in this case\n                if is_mapping and \"type\" not in value:\n                    msg = 'Invalid GeoJSON mapping, missing \"type\"'\n                    err_t = \"invalid_geojson\"\n                    raise PydanticCustomError(err_t, msg)\n                try:\n                    value = shapely.geometry.shape(value)  # type: ignore[bad-argument-type]\n                except (KeyError, ValueError, shapely.errors.ShapelyError) as e:\n                    msg = \"Invalid GeoJSON mapping ({e})\"\n                    err_t = \"invalid_geojson\"\n                    raise PydanticCustomError(err_t, msg, {\"e\": e}) from e\n\n            if not isinstance(value, allowable_types):\n                msg = \"Value was of incorrect type: {t}. {exp}\"\n                subs = {\"t\": type(value).__name__}\n                if len(allowable_types) == 1:\n                    subs[\"exp\"] = f\"Expected {allowable_types[0].__name__}.\"\n                else:\n                    subs[\"exp\"] = (\n                        \"Expected one of: \"\n                        f\"{', '.join(t.__name__ for t in allowable_types)}.\"\n                    )\n                err_t = \"geometry_type\"\n                raise PydanticCustomError(err_t, msg, subs)\n\n            return self._validator(value)\n\n        def serialize(geom: shapely.geometry.base.BaseGeometry) -&gt; dict[str, ty.Any]:\n            return geom.__geo_interface__\n\n        schema = core_schema.no_info_plain_validator_function(validate)\n        return core_schema.json_or_python_schema(\n            json_schema=core_schema.chain_schema(\n                [\n                    core_schema.union_schema(\n                        [core_schema.str_schema(), core_schema.dict_schema()]\n                    ),\n                    schema,\n                ]\n            ),\n            python_schema=schema,\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                serialize,\n                return_schema=core_schema.dict_schema(),\n            ),\n        )\n\n    def __get_pydantic_json_schema__(\n        self,\n        core_schema: core_schema.CoreSchema,\n        handler: pydantic.GetJsonSchemaHandler,\n    ) -&gt; JsonSchemaValue:\n        \"\"\"Get the JSON schema for this field\"\"\"\n        json_schema = handler(core_schema)\n        json_schema = handler.resolve_ref_schema(json_schema)\n        json_schema[\"description\"] = json_schema.get(\n            \"description\", \"No user description\"\n        ) + (\n            \" (WKT string or GeoJSON object with the following constraints: \"\n            f\"{self._validator.summary()})\"\n        )\n        return json_schema\n</code></pre>"},{"location":"api/scientific_pydantic/shapely/#scientific_pydantic.shapely.GeometryAdapter.__get_pydantic_core_schema__","title":"<code>__get_pydantic_core_schema__(source_type: ty.Any, _handler: pydantic.GetCoreSchemaHandler) -&gt; core_schema.CoreSchema</code>","text":"<p>Get the pydantic schema for the shapely geometry</p> Source code in <code>src/scientific_pydantic/shapely/adapters.py</code> <pre><code>def __get_pydantic_core_schema__(\n    self,\n    source_type: ty.Any,\n    _handler: pydantic.GetCoreSchemaHandler,\n) -&gt; core_schema.CoreSchema:\n    \"\"\"Get the pydantic schema for the shapely geometry\"\"\"\n    import shapely\n\n    allowable_types = _get_allowable_types(source_type)\n\n    def validate(value: ty.Any) -&gt; ty.Any:\n        if isinstance(value, shapely.geometry.base.BaseGeometry):\n            pass\n        elif isinstance(value, str):\n            value = _parse_str(value)\n        elif (is_mapping := isinstance(value, Mapping)) or hasattr(\n            value, \"__geo_interface__\"\n        ):\n            # shapely raises an AttributeError in this case\n            if is_mapping and \"type\" not in value:\n                msg = 'Invalid GeoJSON mapping, missing \"type\"'\n                err_t = \"invalid_geojson\"\n                raise PydanticCustomError(err_t, msg)\n            try:\n                value = shapely.geometry.shape(value)  # type: ignore[bad-argument-type]\n            except (KeyError, ValueError, shapely.errors.ShapelyError) as e:\n                msg = \"Invalid GeoJSON mapping ({e})\"\n                err_t = \"invalid_geojson\"\n                raise PydanticCustomError(err_t, msg, {\"e\": e}) from e\n\n        if not isinstance(value, allowable_types):\n            msg = \"Value was of incorrect type: {t}. {exp}\"\n            subs = {\"t\": type(value).__name__}\n            if len(allowable_types) == 1:\n                subs[\"exp\"] = f\"Expected {allowable_types[0].__name__}.\"\n            else:\n                subs[\"exp\"] = (\n                    \"Expected one of: \"\n                    f\"{', '.join(t.__name__ for t in allowable_types)}.\"\n                )\n            err_t = \"geometry_type\"\n            raise PydanticCustomError(err_t, msg, subs)\n\n        return self._validator(value)\n\n    def serialize(geom: shapely.geometry.base.BaseGeometry) -&gt; dict[str, ty.Any]:\n        return geom.__geo_interface__\n\n    schema = core_schema.no_info_plain_validator_function(validate)\n    return core_schema.json_or_python_schema(\n        json_schema=core_schema.chain_schema(\n            [\n                core_schema.union_schema(\n                    [core_schema.str_schema(), core_schema.dict_schema()]\n                ),\n                schema,\n            ]\n        ),\n        python_schema=schema,\n        serialization=core_schema.plain_serializer_function_ser_schema(\n            serialize,\n            return_schema=core_schema.dict_schema(),\n        ),\n    )\n</code></pre>"},{"location":"api/scientific_pydantic/shapely/#scientific_pydantic.shapely.GeometryAdapter.__get_pydantic_json_schema__","title":"<code>__get_pydantic_json_schema__(core_schema: core_schema.CoreSchema, handler: pydantic.GetJsonSchemaHandler) -&gt; JsonSchemaValue</code>","text":"<p>Get the JSON schema for this field</p> Source code in <code>src/scientific_pydantic/shapely/adapters.py</code> <pre><code>def __get_pydantic_json_schema__(\n    self,\n    core_schema: core_schema.CoreSchema,\n    handler: pydantic.GetJsonSchemaHandler,\n) -&gt; JsonSchemaValue:\n    \"\"\"Get the JSON schema for this field\"\"\"\n    json_schema = handler(core_schema)\n    json_schema = handler.resolve_ref_schema(json_schema)\n    json_schema[\"description\"] = json_schema.get(\n        \"description\", \"No user description\"\n    ) + (\n        \" (WKT string or GeoJSON object with the following constraints: \"\n        f\"{self._validator.summary()})\"\n    )\n    return json_schema\n</code></pre>"}]}